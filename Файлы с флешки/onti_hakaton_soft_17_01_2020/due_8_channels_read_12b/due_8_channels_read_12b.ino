int in_ch[] = {A0, A1, A2, A3, A4, A5, A6, A7, A8, A9}; // список каналов, из которых мы будем читать данные
char buff[17];  // массив, в котором будет формироваться пакет данных для пересылки на ПК (буфер)
int cntr; // счетчик отправленных пакетов, ограниченный 10тью битами, как данные с АЦП

void sendData(){
  int num;  
  for( uint8_t ii=0; ii < 5; ii++ ){

// т.к. с АЦП числа приходят 10ти битные, а размер типа integer кратен 8 битам, то хранится это 10ти битное число минимум в 16-ти битном числе типа integer, 
// т.е. при передаче мы будем пересылать 6 заведомо нулевых бит
// Поэтому для уменьшения размера пакета пересылаемых данных сократим количество ненужных бит, и разместим два 10ти битных числа в три восьмибитных
// Этот-же алгоритм без изменений будет работать и для 12ти битных чисел
// для этого нам понадобятся побитовые (или просто битовые) операции сдвига ( обозначаются как >> и << ) и логические операции И и ИЛИ (обозначаются как & и | )
// почитать про них можно например тут https://ru.wikipedia.org/wiki/Битовые_операции
// или например тут https://neerc.ifmo.ru/wiki/index.php?title=Побитовые_операции

    int nn = ii*3 + 2;
    int mm = 11*2;

    num = analogRead( in_ch[ii*2] ); // считываем данные с входного порта
    buff[0 + nn]  = ( num >> 4 ) & 0x00ff; // левую часть 16ти битного числа num, сдвигаем в правые 8 бит
                                           // с помощью "& 0x00ff" зануляем левые 8 бит (по идее они и так будут нулевые, но это небольшая перестраховка для надёжности)
                                           // и кладём то что получилось в 8ми битное число buff[0 + nn]

    buff[1 + nn]  = ( num << 4 ) & 0x00f0; // оставшуюся часть числа num, складываем в правые 4 бита
                                           // с помощью "& 0x00f0" зануляем все остальные биты, которые должны быть нулевыми
                                           // кладём эту половинку в 8ми битное buff[1 + nn]

                                           // таким образом левые 4 бита числа buff[1 + nn] у нас стали заняты, а правые - ещё свободны

    num  = analogRead( in_ch[ii*2 + 1] );   // считываем данные со следующего входного порта
    buff[1 + nn] |= ( num >> 8 ) & 0x000f;  // положим в правые 4 бита числа buff[1 + nn] ещё кусочек обновлённого числа num
    buff[2 + nn]  =   num        & 0x00ff;  // и оставшуюся часть числа num положим в buff[2 + nn]

    // таким образом получилось, что из 4х бит занимаемых числами num[mm + 1], мы переложили наши данные в 3 бита, т.е уменьшили передаваемый "траффик" на четверть
    // подобным-же образом можно разместить 3 10-битных числа в 4х 8-битных и ещё больше сократить траффик.
  }
  
// путём нехитрых манипуляций помещаем число cntr в конец пакета
  buff[1 + 2 + 4*3] &= 0x00f0;
  buff[1 + 2 + 4*3] |= ( cntr >> 8 ) & 0x000f;
  buff[2 + 2 + 4*3]  =   cntr        & 0x00ff;

 Serial.write( buff, 17);
// увеличиваем счетчик отправленных пакетов, не забывая что он 10ти битный
  cntr +=1; if(cntr > 1024) cntr = 0;
}

// функция setup вызывается однократно при запуске Arduino
void setup(){
  cntr = 0;
  // по первым двум числам в буфере программа-визуализатор данных запущенная на компьютере будет опознавать начало посылки.
  buff[0] = 0x35;
  buff[1] = 0x2c;
  Serial.begin(115200);                    // инициализируем Serial-порт на скорости 115200 Кбит/c. 
}

void loop(){
  delay( 4 ); // устанавливаем частоту опроса аналоговых портов и передачи данных приблизительно на 250Гц
  sendData();
}
