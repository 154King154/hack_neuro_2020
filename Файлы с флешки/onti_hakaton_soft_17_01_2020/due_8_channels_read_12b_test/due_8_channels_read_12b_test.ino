char buff[17]; // массив, в котором будет формироваться пакет данных для пересылки на ПК (буфер)
uint16_t num[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10}; // массив, в котором хранятся сгенерированные тестовые данные, и его инициализация
uint16_t inc[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}; // массив, в котором хранятся приращения для каждого числа из тестовых данных


void sendData(){
  
  for( uint8_t ii=0; ii < 5; ii++ ){

// вычисляем текущие значения тестовых данных
    num[ii*2] += inc[ii*2];
    num[ii*2+1] += inc[ii*2+1];
    
// т.к. данные у нас должны быть 10ти битные ( как разрешение АЦП на большинстве Arduino)- ограничиваем максимальное значение числом 1023
    if(num[ii*2] > 1023) num[ii*2] = 0;
    if(num[ii*2+1] > 1023) num[ii*2+1] = 0;

// т.к. с АЦП числа приходят 10ти битные, а размер типа integer кратен 8 битам, то хранится это 10ти битное число минимум в 16-ти битном числе типа integer, 
// т.е. при передаче мы будем пересылать 6 заведомо нулевых бит
// Поэтому для уменьшения размера пакета пересылаемых данных сократим количество ненужных бит, и разместим два 10ти битных числа в три восьмибитных
// Этот-же алгоритм без изменений будет работать и для 12ти битных чисел
// для этого нам понадобятся побитовые (или просто битовые) операции сдвига ( обозначаются как >> и << ) и логические операции И и ИЛИ (обозначаются как & и | )
// почитать про них можно например тут https://ru.wikipedia.org/wiki/Битовые_операции
// или например тут https://neerc.ifmo.ru/wiki/index.php?title=Побитовые_операции

    int nn = ii*3 + 2;
    int mm = ii*2;
    
    buff[0 + nn]  = ( num[mm] >> 4 ) & 0x00ff; // левую часть 16ти битного числа num[mm], сдвигаем в правые 8 бит
                                               // с помощью "& 0x00ff" зануляем левые 8 бит (по идее они и так будут нулевые, но это небольшая перестраховка для надёжности)
                                               // и кладём то что получилось в 8ми битное число buff[0 + nn]
                                               
    buff[1 + nn]  = ( num[mm] << 4 ) & 0x00f0; // оставшуюся часть числа num[mm], складываем в правые 4 бита
                                               // с помощью "& 0x00f0" зануляем все остальные биты, которые должны быть нулевыми
                                               // кладём эту половинку в 8ми битное buff[1 + nn]

                                               // таким образом левые 4 бита числа buff[1 + nn] у нас стали заняты, а правые - ещё свободны

    buff[1 + nn] |= ( num[mm + 1] >> 8 ) & 0x000f; // положим в правые 4 бита числа buff[1 + nn] ещё кусочек числа num[mm + 1]
    buff[2 + nn]  =   num[mm + 1]        & 0x00ff; // и оставшуюся часть числа num[mm + 1] положим в buff[2 + nn]

    // таким образом получилось, что из 4х бит занимаемых числами num[mm + 1], мы переложили наши данные в 3 бита, т.е уменьшили передаваемый "траффик" на четверть
    // подобным-же образом можно разместить 3 10-битных числа в 4х 8-битных и ещё больше сократить траффик.
  }
  
  Serial.write( buff, 17);
}

// функция setup вызывается однократно при запуске Arduino
void setup(){
  // по первым двум числам в буфере программа-визуализатор данных запущенная на компьютере будет опознавать начало посылки.
  buff[0] = 0x35;
  buff[1] = 0x2c;
  Serial.begin(115200);                    // инициализируем Serial-порт на скорости 115200 Кбит/c. 
}


void loop(){
  delay( 4 ); // устанавливаем частоту опроса аналоговых портов и передачи данных приблизительно на 250Гц
  sendData();
}
